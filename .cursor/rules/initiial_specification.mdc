---
description: 
globs: 
alwaysApply: true
---
Comprehensive Specification · Agentic Web Platform Prototype

Purpose — A single source‑of‑truth specification that is both human–readable and LLM‑parsable (Cursor‑ready) for scaffolding a working prototype from scratch.

1 · Concept & Product Goals

1.1 Why “Agentic”?

Modern AI assistants lose reliability when given broad, ill‑defined mandates. This platform instead composes narrow agents—each with a single trigger and a single deterministic outcome—thereby reducing hallucination, simplifying testing, and letting users layer precisely the automations they trust.

1.2 Data‑Driven Automation

The user’s own data is the engine. Every suggestion, clarification, or automation stems from observed behaviour in their connected services. No data ⇒ no suggestions. As new data arrives or the user provides feedback, the solution space evolves.

Example: Connecting Gmail reveals that 38 % of incoming mail are newsletters that remain unread. That statistic—not a template—leads to an Auto‑Archive Newsletter agent suggestion.

1.3 Human‑in‑Loop (HIL)

At every outward‑facing step the human must explicitly approve, edit, or reject. Nothing is executed automatically in the prototype. Over time, approvals may opt‑in to full automation, but HIL is the default safety rail.

2 · Technical Architecture Overview

Layer

Technology

Notes

Front‑end

React 18 + Vite + Chakra UI

SPA, fast dev reload, accessible components

State (FE)

React Context + localStorage

All transient & UI state local; serialised JSON schema below

Back‑end

Node 20 / Express

Only Gmail OAuth & Zep proxy; analysis runs client‑side for prototype

Memory

getzep.com

Append‑only long‑term knowledge graph

LLM

Runtime‑best model

No hard‑coded GPT‑version; model id provided via .env

Monorepo Structure

/agentic‑platform
  /client   # React source
  /server   # Express API (minimal)
  package.json (workspace root)

No /shared folder—any common types can be duplicated or imported via generated SDK if needed.

3 · User Experience & Interface

3.1 Initial On‑Boarding (Zero‑State → First Data)

Landing Card (only UI element): “Do you use Gmail?” → Yes (required).

Client redirects to /auth/gmail (OAuth consent).

Callback → temporary Syncing… card with spinner + progress (emails fetched, analysis running locally via Web Worker).

Analysis resolves → Sidebar appears, Memory populated, first Action card queued.

3.2 Layout Cheat‑Sheet

┌──────────────────────────────────────────────┐
│     Top Bar (brand, dark‑mode toggle)        │
├───┬───────────────────────────────────────────┤
│ S │                                           │
│ I │         Main Content Panel               │
│ D │                                           │
│ E │                                           │
│ B │                                           │
│ A │                                           │
│ R │                                           │
└───┴───────────────────────────────────────────┘

Sidebar Items (collapsible):

Actions (badge) – single‑card view.

Memory – search input pinned top.

Connections – list of linked services; Gmail shows ✅ / error.

Active Agents – list by title.

Suggested Agents – history with statuses.

3.3 Action Card Types (one at a time)

HIL Execution – approve / edit / reject impending agent act.

HIL Clarification – free‑form textarea.

HIL Decision – radio / checklist.

Knowledge Question – Y/N, multi‑choice, or short text; stores to memory.

Suggested Agent – approve / edit / reject idea.

Suggested Data‑Source Connection – e.g., “Link Calendar to improve scheduling agents.”

The queue is prioritised by server‑side analysis score; user must complete (or explicitly snooze) current card to see the next.

3.4 Memory Tab (MVP)

Flat list of sentences with search box (Fuse.js fuzzy search client‑side).

Each entry shows text, timestamp, and [inferred] or [user] source tag.

No categorisation UI yet.

4 · Back‑End Responsibilities

4.1 Endpoints

Method

Route

Purpose

GET

/auth/gmail

Build Google OAuth URL; redirect user

GET

/auth/gmail/callback

Exchange code→tokens; respond <script> to notify opener; persists tokens in memory

POST

/zep/write

(Optional) Proxy a write to Zep (body {content, meta})

GET

/zep/read

(Optional) Retrieve user memory for export

Minimalist: if we run analysis client‑side, Zep proxy may be skipped by supplying Zep API‑key in client env for prototype.

4.2 Token Storage (Prototype)

In‑memory Map keyed by session cookie.

Not persisted across server restarts (acceptable for demo).

5 · Data Processing & Analysis Pipeline (Client Side)

#

Stage

Detail

1

Email Harvest

Fetch last 100 Gmail messages (messages.list + messages.get). Extract headers, snippet, plaintext.parts.

2

Source Doc Batching

Chunk email corpus ≤8 k tokens per LLM call.

3

Insight Extraction

Prompt: "Given these emails, list factual statements about the user’s identity, contacts, habits, preferences. Output bullet list."

4

Memory Write

For each bullet, POST to Zep with {source:"gmail", evidence:messageIds[]}.

5

Knowledge‑Gap Detection

Prompt: "Based on known facts <...>, what missing info would most improve personalised automation? Return 3‑5 user‑friendly questions."

6

Agent Idea Generation

Prompt: "Given the user facts and Gmail API capabilities, propose up to 5 narrow agents. Each must reference evidence from the data (include messageIds) and justify usefulness."

7

Spec Synthesis

For each idea, prompt: "Draft JSON spec with keys: title, description, trigger, action, tools, humanInLoop[], implementationNotes."

8

Scoring & Queue Build

Heuristic: (evidence_count × predicted_frequency × user_time_saved) → descend; interleave questions and agents; push to actionQueue.

All prompts include strict JSON modes to simplify parsing.

6 · Agent Specification Schema (Ver. 0.1)

{
  "id": "string-uuid",
  "title": "string",
  "description": "string",
  "trigger": "string",
  "action": "string",
  "tools": ["gmail.messages.modify"],
  "humanInLoop": ["string"],
  "implementationNotes": "string",
  "evidence": ["gmailMessageId1", "gmailMessageId2"],
  "status": "suggested" // client may update → "approved" | "rejected"
}

Notice evidence links each suggestion to specific user emails, reinforcing data‑derived provenance.

7 · Front‑End State Shape

type RootState = {
  gmailConnected: boolean;
  syncStatus: "idle" | "syncing" | "done" | "error";
  actionQueue: ActionItem[];
  agentSuggestions: AgentSpec[];
  activeAgents: AgentSpec[];
  memoryCache: KnowledgeEntry[];
  lastSync: string; // ISO timestamp
};

Serialised to localStorage under key agentic‑state.

8 · Startup Sequence (Happy Path)

LandingCard → OAuth → SyncingCard → Analysis Pipeline →
  MemoryView ready & ActionCard #1 displayed →
  user iterates queue (state mutates) →
  approvals mark agents active / memory expands → rinse + repeat.

9 · Non‑Goals (Prototype Scope)

No real email‑sending or label‑modifying execution.

No multi‑service orchestration (one service at a time).

No server‑side persistence beyond runtime memory.

No CI/CD or containerisation.

End of Specification

